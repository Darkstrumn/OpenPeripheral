package openperipheral;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import argo.jdom.JdomParser;
import argo.jdom.JsonField;
import argo.jdom.JsonNode;
import argo.jdom.JsonRootNode;

import net.minecraft.tileentity.TileEntity;
import net.minecraftforge.common.Configuration;
import net.minecraftforge.common.Property;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.Mod;
import cpw.mods.fml.common.Mod.Instance;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import cpw.mods.fml.common.registry.TickRegistry;
import cpw.mods.fml.relauncher.FMLRelauncher;
import cpw.mods.fml.relauncher.Side;
import dan200.computer.api.ComputerCraftAPI;


@Mod( modid = "OpenPeripheral", name = "OpenPeripheral", version = "0.0.4")
public class OpenPeripheral
{
	
	public static ArrayList<MethodDefinition> peripheralMethods = new ArrayList<MethodDefinition>();
	public static HashMap<Class, ArrayList<MethodDefinition>> methodCache = new HashMap<Class, ArrayList<MethodDefinition>>();
	
	public static HashMap<String, IReplacement> replacements = new HashMap<String,IReplacement>();
	
	@Instance( value = "OpenPeripheral" )
	public static OpenPeripheral instance;

	@Mod.PreInit
	public void preInit( FMLPreInitializationEvent evt )
	{
		ModContainer container = FMLCommonHandler.instance().findContainerFor(OpenPeripheral.instance);
		String version = container.getVersion();
		Configuration configFile = new Configuration(evt.getSuggestedConfigurationFile());
		
		Property prop = configFile.get("general", "enableAnalytics", true);
		prop.comment = "Do you want analytics enabled?";
		
		boolean pingAnalytics = false;
		boolean analyticsDisabled = false;
		
		if (!prop.getBoolean(true)) {
			pingAnalytics = false;
			analyticsDisabled = true;
		}
		
		if (!configFile.hasKey("general", "currentVersion")) {
			pingAnalytics = true;
		}
		
		prop = configFile.get("general", "currentVersion", version);
		prop.comment = "Do not edit this file. OpenPeripheral adds no blocks or items! this value should not be changed";
		
		if (prop.getString() != version) {
			pingAnalytics = true;
		}
		
		if (pingAnalytics && !analyticsDisabled) {
			try {
				String charset = "UTF-8";
				String url = String.format(
						"http://www.openccsensors.info/op_analytics?version=%s&side=%s&forge=%s",
						URLEncoder.encode(container.getVersion(), charset),
						URLEncoder.encode(FMLRelauncher.side(), charset),
						URLEncoder.encode(version, charset)
				);
				URLConnection connection = new URL(url).openConnection();
				connection.setConnectTimeout(4000);
				connection.setRequestProperty("Accept-Charset", charset);
				InputStream response = connection.getInputStream();
			}catch(Exception e) {
				
			}
		}
		prop.set(version);
		configFile.save();
		initializeReplacements();
	}

	@Mod.Init
	public void init( FMLInitializationEvent evt )
	{
		URL url;
		try {
			url = new URL("https://raw.github.com/mikeemoo/OpenPeripheral/master/methods.json");
			//url = new URL("http://localhost/methods.json");
			URLConnection con = url.openConnection();
			Reader r = new InputStreamReader(con.getInputStream(), "UTF-8");
		    JdomParser parser = new JdomParser();
		    JsonRootNode root = parser.parse(r);
		    for (JsonNode element : root.getElements()) {
		    	parseJson(element);
		    }
		    
			TickRegistry.registerTickHandler(new TickHandler(), Side.SERVER);
			ComputerCraftAPI.registerExternalPeripheral(TileEntity.class, new PeripheralHandler());

		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

	private void parseJson(JsonNode node) {
		String className = node.getStringValue("class");
		Class clazz = null;
		try {
			clazz = Class.forName(className);
		} catch (ClassNotFoundException e) {
			
		}
		if (clazz == null) {
			return;
		}

		HashMap<String, String> obfuscatedNames = new HashMap<String, String>();
		for (JsonField field : node.getNode("obfuscated").getFieldList()) {
			obfuscatedNames.put(field.getName().getText(), field.getValue().getText());
		}
		
		ArrayList<String> allowedMethods = new ArrayList<String>();
		HashMap<String, JsonNode> jsonMethods = new HashMap<String, JsonNode>();
		for (JsonField field : node.getNode("methods").getFieldList()) {
			jsonMethods.put(field.getName().getText(), field.getValue());
		}
		
		if (node.isNode("properties")) {
			JsonNode propertiesJson = node.getNode("properties");
			for (JsonField propertyField : propertiesJson.getFieldList()) {
				Field field = null;
				try {
					field = clazz.getDeclaredField(propertyField.getName().getText());
					field.setAccessible(true);
				}catch(Exception e) {
					e.printStackTrace();
				}
				if (field != null) {
					JsonNode nodeValue = propertyField.getValue();
					if (nodeValue.isNode("set")) {
						peripheralMethods.add(new MethodDefinition(nodeValue.getNode("set").getText(), field, false));
					}
					if (nodeValue.isNode("get")) {
						peripheralMethods.add(new MethodDefinition(nodeValue.getNode("get").getText(), field, true));	
					}
				}
			}
		}
		
		for (Method method : clazz.getMethods()) {
			if (jsonMethods.containsKey(method.getName())) {
				peripheralMethods.add(new MethodDefinition(method.getName(), method, jsonMethods.get(method.getName())));
			}else if (obfuscatedNames.containsKey(method.getName())) {
				String obfuscatedName = obfuscatedNames.get(method.getName());
				peripheralMethods.add(new MethodDefinition(obfuscatedName, method, jsonMethods.get(obfuscatedName)));	
			}
		}
	}

	public static ArrayList<MethodDefinition> getMethodsForClass(
			Class<? extends TileEntity> clazz) {
		
		if (!methodCache.containsKey(clazz)) {
			ArrayList<MethodDefinition> methods = new ArrayList<MethodDefinition>();
			for (MethodDefinition method : peripheralMethods) {
				if (method.isValidForClass(clazz)) {
					methods.add(method);
				}
			}
			methodCache.put(clazz, methods);
		}
		return methodCache.get(clazz);
		
	}
	
	private void initializeReplacements() {
		replacements.put("x", new IReplacement() {
			@Override
			public Object replace(TileEntity tile) {
				return tile.xCoord;
			}
		});
		replacements.put("y", new IReplacement() {
			@Override
			public Object replace(TileEntity tile) {
				return tile.yCoord;
			}
		});
		replacements.put("z", new IReplacement() {
			@Override
			public Object replace(TileEntity tile) {
				return tile.zCoord;
			}
		});
		replacements.put("world", new IReplacement() {
			@Override
			public Object replace(TileEntity tile) {
				return tile.worldObj;
			}
		});

	}
}